var assert = require('assert');
const path = require("path");
     const fs = require("fs");
//const  TxOriginVictim = artifacts.require("TxOriginVictim")
//const TxOriginAttacker= artifacts.require("TxOriginAttacker")
//const  F5 = artifacts.require("F5")
//const ST5= artifacts.require("ST5")

module.exports = async function(callback) 
{
   try{
          var ctr =0;//cnt of program statements stored in keyWordStr, note there can be multiple statements relted to each keyWords, e.g there can be multiple functions
                     //hence ctr can be greater than number of keyWords i.e. 9
          const keyWordStr = [];
          const keyWordCntArr = [];
          const files = new Array(/*"A1.sol","A2.sol", "A3.sol","2DappUniv.sol",*/ "OwnableWallet.sol");
          const attFiles = new Array(/*"2DappUnivAtt.sol",*/"2DappUnivAtt.sol"/*TxOriginAttacker1.sol","TxOriginAttackersafe.sol", "TxOriginAttackerNsafe.sol","TxOriginAttackers2.sol","TxOriginAttackerNs2.sol"*/);
          const keyWords = new Array(/*"pragma solidity",*/ "contract" ,"call.", "tx.origin",  "function", "address", "send(", "transfer(", "constructor");
          let f_linenum = [];
          let tx_linenum = -1
          let tx_index = -1
          let call_index = -1
          let call_linenum =-1
          let send_linenum = -1
          let transfer_linenum = -1
          let send_index = -1
          let transfer_index = -1
          let sendFound = false
          let transferFound = false
          let funcStr= []
          let keyWordFoundCnt = 0//This holds the Cnt of keyWords Found i.e., "function" keyword can come more than once 
          let reentrancy_found = false;
          let tx_origin_found = false;
          let function_keyword_search_starts = false;
          let function_keyword_start_ctr = -1
          let function_keyword_search_ends = false;
          let function_keyword_end_ctr = -1
          let funcCtr =0
          let argArr_TypeAndNameCombined = []//contains space separating argument type and name
          let argArr_TypeAndNameSeparated1 = ""
          let argArr_TypeAndNameSeparated2 = ""
          let transferFuncName = null
          let argArray=""
          let argStrWithComma= null
          let argStrN=[[],[]]
          let result2 = -1
          let keyWordFound = false
          let tx_call_func_linenum = 0
          let call_func_linenum = 0
          let send_func_linenum = 0
          let transferSolid_func_linenum = 0
          let tx_call_func_name = []
          let txStr = ""
          let call_func_name = []
          let send_func_name = []
          let transferSolid_func_name = []
          let arg1 = ""
          let arg2 = 0
          let type1 = ""
          let type2 = ""
          let type =""
          let no_argument = false
          let transferStr = ""
          let sendStr = ""
          let categoryStr = ""
           
          for (let i = 0; i <files.length; i++) { 
             
             ctr=0
             f_linenum = [];
             tx_linenum = -1
             tx_index = -1
             call_index = -1
             call_linenum =-1
             send_linenum = -1
             transfer_linenum = -1
             send_index = -1
             transfer_index = -1
             funcStr= []
             //funcCtr =0
             keyWordFoundCnt = 0//This holds the Cnt of keyWords Found i.e., "function" keyword can come more than once 
             reentrancy_found = false;
             tx_origin_found = false;
             function_keyword_search_starts = false;
             function_keyword_start_ctr = -1
             function_keyword_search_ends = false;
             function_keyword_end_ctr = -1
             funcCtr =0
             argArr_TypeAndNameCombined = []//contains space separating argument type and name
             argArr_TypeAndNameSeparated1 = ""
             argArr_TypeAndNameSeparated2 = ""
             transferFuncName = null
             argArray=""
             argStrWithComma=null
             argStrN=[[],[]]
             result2 = -1
             keyWordFound = false
             tx_call_func_linenum = 0
             tx_call_func_name = []
             txStr = ""
             call_func_name = []
             send_func_name = []
             transferSolid_func_name = []
             arg1 = ""
             arg2 = 0
             type1 = ""
             type2 = ""
             type =""
             transferStr = ""
             sendStr = ""
             send_index = -1
             transfer_index = -1
             sendFound = false
             transferFound = false
             call_func_linenum = 0
             send_func_linenum = 0
             transferSolid_func_linenum = 0
             categoryStr = ""
             const contractPath = path.resolve('/home/zulfi/Truffle_programs/txorigin_assertion_TechyTech_tool/','contracts',files[i]);
             console.log("file name = " + files[i])
             keyWordStr[ctr] = files[i]; 
             no_argument = false
             ctr++;
             const contractCode2 = fs.readFileSync(contractPath, "utf8");
             let lines =   contractCode2.split(/\r\n|\n/); //number of lines in file
             for (let keyWordCtr = 0; keyWordCtr <9; ++keyWordCtr){//processes keyWords array
                keyWordFound = false;
                //console.log("@@Keyword = "+keyWords[keyWordCtr]+"keyWordCtr= " + keyWordCtr)
                if(keyWordCtr === 3) {//In the keywords array, index of "call" is 1 and the index of "tx.origin" is 2, so at iteration#2 we know that tx.origin or reentrancy found or not
                   // reentrancy_found = check_reentrancy_found(); Note we can detect call and tx.origin using search(keyWords[keyWordCtr]) < 0 condition. No need for
                   // functions to detect reentrancy and tx.origin
                   //tx_origin_found = check_tx_origin_found();
                   function_keyword_search_starts = true;
                   function_keyword_start_ctr = ctr
                   if (!reentrancy_found && !tx_origin_found){
                      console.log("Both reentrancy and tx.origin not found in the file " +files[i]);
                      break;//process next SC
                   }
                   else if(reentrancy_found && tx_origin_found)
                      console.log("Both reentrancy and tx.origin maybe present")
                   else if (reentrancy_found && !tx_origin_found)
                      console.log("reentrancy maybe present but tx.origin not found")
        
                   else
                      console.log("reentrancy not found and tx.origin  found")     
                }//if(keyWordCtr === 3) {
                //console.log("^^KWCtr="+keyWordCtr+"len(line) ="+lines.length)
                for(let line = 0; line < lines.length-1; line++){
                   //console.log("@@KWCtr="+keyWordCtr+"len(line) ="+lines.length + "Line = " +lines[line])
                   //why ignoring KWctr 3 to 7, if there is no reentrancy and tx.origin vulnerability, we would go to next SC
                   //console.log("&&KWCtr= "+keyWordCtr+" line ="+line+"statement="+lines[line])
                   //search a string within parenthesis: https://stackoverflow.com/questions/39996539/search-inside-txt-file-using-javascript
                   //console.log(keyWords[keyWordCtr] + " " + keyWordCtr+ " " + lines[line]+ "search res=" + (lines[line].search(keyWords[keyWordCtr]) >= 0));
                   //if (lines[line].search(keyWords[keyWordCtr]) < 0)//Note replacing search by includes not working
                   //if(keyWordCtr ==6)
                   //console.log("@@KWCtr="+keyWordCtr+"len(line) ="+lines.length + "Line = " +lines[line])
                   if (lines[line].includes(keyWords[keyWordCtr]) == false){
                      //console.log("@@Inside continue Block, lineCnt = "+line+"lines[line]= "+lines[line])
                      //keyWordStr[ctr] = " "+ keyWords[keyWordCtr] + " = "+" "+ "Not Found";
                      //ctr++
                      continue;
                   }//if (lines[line].includes(keyWords[keyWordCtr]) == false){
                   if(keyWordCtr==1)//found call, keyWordCtr is the index of Solidity reserve words in keywords arr
                      reentrancy_found = true;
                   else if(keyWordCtr == 2)//found tx.origin
                      tx_origin_found = true;
                   keyWordFoundCnt++;
                   if(keyWordCtr==0){
                       //console.log("??KWCtr="+keyWordCtr)
                       keyWordStr[ctr] = (lines[line].search(keyWords[keyWordCtr]) >= 0 ? /*line.toString()+" = " +*/ " "+ keyWords[keyWordCtr] + " = "+" "+ lines[line] : false);
                      // ctr++;
                       keyWordFound = true
                   }
                   else{
                        //console.log("%%KWCtr="+keyWordCtr)
                       //keyWordStr[ctr] = (lines[line].search(keyWords[keyWordCtr]) >= 0 ? line.toString()+" = " + " "+ keyWords[keyWordCtr] + " = "+" "+ lines[line] : false);
                       keyWordStr[ctr] = (lines[line].includes(keyWords[keyWordCtr]) ? line.toString()+" = " + " "+ keyWords[keyWordCtr] + " = "+" "+ lines[line] : false);
                       //keyWordStr[ctr] = (lines[line].includes(keyWords[keyWordCtr]) ? line.toString()+" = " + " "+ keyWords[keyWordCtr] + " = "+" "+ lines[line] : "-1" + " = " + " " +                  
                       //   keyWords[keyWordCtr] + " = " + "NOT FOUND");
                       //if(keyWords[
                       keyWordFound = true;
                       //ctr++;
                   }
                   
                   //if ((keyWordCtr == 0 || keyWordCtr == 1)  && (lines[line].search(keyWords[keyWordCtr]) >= 0))
                   //break;
                   //keyword name, keyword index i.e. keyWordCtr, keyword's line# in the SC, count of keyword 
                   console.log("keyword found ="+ (keyWords[keyWordCtr]))
                    ctr++; //Good
                }//for(let line = 0; line < lines.length-1; line++){
                if(!keyWordFound){
                   keyWordStr[ctr]= "-1" + " = " + " " + keyWords[keyWordCtr] + " = " + "NOT FOUND"   
                   ctr++
                   //keyWordFound = true
                }
                if (function_keyword_search_starts){
                   function_keyword_search_ends = true;
                   function_keyword_end_ctr = ctr
                   function_keyword_search_starts =false
                }
                keyWordCntArr[keyWordCtr] = keyWordFoundCnt;
                keyWordFoundCnt = 0;
                //ctr++ This was changing the order i.e. if tx_origin not present, tx_origin line merges with function data
                //console.log("**KWCtr= "+keyWordCtr)
             }//for (let keyWordCtr = 0; keyWordCtr <9; ++keyWordCtr){

             if (!reentrancy_found && !tx_origin_found){// there is no vulnerability to check
                for(let k=0; k<ctr; k++)
                   keyWordStr[k]='';
                ctr=0
                console.log("Both tx.origin and reentrancy not found in "+ keyWordStr[0] + "Stop")
                continue;
             }
             console.log("Strings related to the found keywords");
             for(let k=0; k<ctr; k++)
                console.log("k= "+ k +" " + keyWordStr[k] );
             console.log("Before printing count of all keywords");
             for(let k=0; k<8; k++)
                console.log("k= "+ k +" " + keyWords[k] + " = "+keyWordCntArr[k] + " "  + keyWordStr[k]);
             console.log("Before printing only keyword strings retrieved from code");
             //send and transfer linenum
             let commandS="send("
             console.log("next!!!")
             let commandT="transfer("
             console.log("next!!!")
             for(let k=0; k<ctr; k++){
                console.log("1k="+k)
                if (keyWordStr[k] == null){
                   console.log("2k="+k)
                   continue;
                }
                else if(keyWordStr[k].includes(commandS) == true){
                   sendStr = keyWordStr[k]
                   console.log("^^^IMP"+sendStr)
                }
                else if(keyWordStr[k].includes(commandT) == true){
                   console.log("4k= "+k+ "Found")
                   transferStr = keyWordStr[k]
                   console.log("^^^" + transferStr)
                }
                console.log("5k= "+ k + " "  + keyWordStr[k]);   
             }//for(let k=0; k<ctr; k++){
             console.log("@@@sendStr= "+sendStr)
             console.log("@@@transferStr= " + transferStr)
             if (!reentrancy_found){
                console.log("0Entered")
                if(sendStr.search("NOT FOUND")>= 0){
                   sendFound = false  
                   console.log("00Entered")
                }
                else
                sendFound = true
             }
             if(!sendFound){
                console.log("000Entered")
                if(transferStr.search("NOT FOUND")>= 0){
                   transferFound = false 
                   console.log("Entered1")
                }
                else{
                   transferFound = true
                    console.log("Entered2")
                }
             } 
             console.log("@@@ sendFound = " + sendFound + "@@@ transferFound = " + transferFound)


             let position = -1            
             for (let j = 0; j <ctr; j++) { 
                //let limit = j +  keyWordCntArr[j]
                console.log("beginning j= " +j+ " limit="+ " " +keyWordCntArr[j]); //keyWordCntArr means number of search counts for each element of keywords array
                //console.log("j= " + j +" "+keyWordStr[j]);
                //for (k=0; k<limit; ++k) {
                //}
                //at the end of loop j = limit;
                //j=0 contains filename   
                if(j==1 ) {
                   console.log("inside j==1");
                   //Not Required for function keyword
                   let m = j
                   
                   console.log("%%%Counter =" + ctr+  "keyWordStr[m]=" +  keyWordStr[m])
                   while(m < ctr){
                      console.log("Inside while loop m=" + m)
                      if(keyWordStr[m] == null){
                         m++
                         continue;
                      }
                      else {
                         console.log("Inside while loop, else part,  m=" + m)
                         position = keyWordStr[m].search("contract")
                         //position= "This is contract".search("contract")
                         console.log("!!position = " + position + "string =" + keyWordStr[m] )
                         break
                         
                      }
                   }//while(m < ctr)
                   contractStr = keyWordStr[m]
                   if (position != -1)              
                      contractName = findContractName(contractStr);
                   else {
                         console.log("CONTRACT NOT FOUND: PROBLEM")
                         return
                   }
                   console.log("!contractName =" + contractName);
                   //following is a running code, to be added once we detect the name of function containing "call", "send", "transfer", "tx.origin"
                   
                   /*const accounts = await web3.eth.getAccounts();
                   const acc2 = accounts[2];
                   acc2bal = await web3.eth.getBalance(acc2);
                   web3.utils.fromWei(acc2bal, "ether");
                   console.log('!acc2 balance', acc2bal, 'address',acc2);
                   const vic= artifacts.require(contractName);
                   const att= artifacts.require("TxOriginAttacker.sol");
                   const vicobj = await vic.new();
                   const attobj = await att.new();
                  
                   vicbal = await web3.eth.getBalance(vicobj.address)
                   web3.utils.fromWei(vicbal, "ether")
                   console.log(`Initial Victim:`,vicobj.address,` balance is ${vicbal}`)
                   attbal = await web3.eth.getBalance(attobj.address)
                   web3.utils.fromWei(attbal, "ether")
                   console.log(`Initial Attacker:`,attobj.address,` balance is ${attbal}`)
                   amount = '11'
                   result1 = await web3.eth.sendTransaction({to:vicobj.address, from:acc2, value: web3.utils.toWei(amount)})
                   console.log("receipt  : ", result1)
                   console.log("sender   : ", result1.from)
                   console.log("receiver : ", result1.to)
                   vicbal = await web3.eth.getBalance(vicobj.address)
                   web3.utils.fromWei(vicbal, "ether")
                   console.log(`Deposited ${amount} Ether from acc2:${acc2}, to victim:`, vicobj.address,` balance is ${vicbal}`)
                   amount = '6'
                   vicPrevBal = vicbal
                   result2 = await vicobj.transferTo(attobj.address, web3.utils.toWei(amount,"ether"), {from:accounts[0]})
                   console.log("receipt  : ", result2)
                   console.log("sender   : ", result2.from)
                   console.log("receiver : ", result2.to)
                   console.log(`Deposited ${amount} Ether to Attacker from victim:`, vicobj.address)
                   vicbal = await web3.eth.getBalance(vicobj.address)
                   web3.utils.fromWei(vicbal, "ether")
                   attbal = await web3.eth.getBalance(attobj.address)
                   web3.utils.fromWei(attbal, "ether")
                   console.log(`After deposit, Victim:`,vicobj.address,` balance is ${vicbal}`)
                   console.log(`After deposit, Attacker:`,attobj.address,` balance is ${attbal}`)*/

               
                   //assert.equal(acc3bal,0 ,"acc3 balance after transfer is Zero");
   
    
                   //Attacker balance is not correct
                   //https://www.programmersought.com/article/25227382926/
                   //result.receipt;
    
                   /* correct code, commenting to complete the other parts
                   try{
                      assert.equal(vicbal,vicPrevBal ,"(1)Victim balance after transfer is Zero");
                   }catch(err){
                      console.log(err)
                   }
                   try{
                      assert.equal(vicobj.address, attobj.address, "(2)Victim address is not same as the receiver or attacker address");
                   }catch(err){
                      console.log(err)
                   }
                   */
                   //This assertion is not true therefore victim is not the beneficary  of the transaction
                   /*  try{

                          assert.equal(attbal, '0', "(3)After transfer Attacker Balance is same as Victim's balance before transfer"); 
                       }catch(err){
                          console.log(err)
                       }*/
                }/*if(j==1 && j<limit) {*/
                else if(j==2 ) {
                   console.log(" ! inside j==2 " + j +"reentrancy_found=" + reentrancy_found + " call statement= " + keyWordStr[2]); 
                   if(reentrancy_found){ 
                      call_linenum= find_call_line_number(keyWordStr[2])
                      console.log("call_linenum found, call_linenum=" + call_linenum)
                   }
                   else
                      console.log("No need to find call_linenum, call_linenum=" + call_linenum)
                }//if(j==2 ) {
                else if(j==3  ) {
                   console.log(" ! inside j==3 " + j +"txorigin_found=" + tx_origin_found +" txorigin statement= " + keyWordStr[3]); 
                   if(tx_origin_found){  
                      tx_linenum = parseInt(find_txorigin_line_number(keyWordStr[3]))
                      txStr = keyWordStr[3]
                      x = tx_linenum+ 30
                      console.log("tx_linenum found, tx_linenum=" + tx_linenum +"!x1=" + x)
                   }
                   else
                      console.log("No need to find tx_linenum, tx_linenum=" + tx_linenum +"!x1=" + x)
                }//if(j==3  ) {
                else if(j>=function_keyword_start_ctr && j<function_keyword_end_ctr ) {
                   console.log("function_keyword_start_ctr="+function_keyword_start_ctr)
                   console.log("function_keyword_end_ctr="+function_keyword_end_ctr)
                   console.log(" ! Enters inside j== 4+ " + j +" function statement= " + keyWordStr[j]);  
                   funcStr[funcCtr]  = keyWordStr[j]
                   f_linenum[funcCtr] = find_function_line_number(keyWordStr[j])
                   funcCtr++
                }
                   
             }//for (let j = 0; j <ctr; j++) {
             //Now processing the information relted to keyWords stored in  keyWordStr  
             //find the function containing tx.origin and call
             console.log("###?? Outside keywordStr analysis loop, tx_linenum= "+tx_linenum+"!x2=" + "call_linenum =" + call_linenum)
             x = tx_linenum+ 30
             console.log("###?? Outside keywordStr analysis loop, tx_linenum= "+tx_linenum+"!x2=" + x + "tx_origin_found =" + tx_origin_found)
             if(tx_origin_found){
                tx_index=find_the_txindex_of_flinenum(tx_linenum, f_linenum, funcCtr) 
                console.log("!tx_index = " +tx_index)
             }
             else
                 console.log("###?? tx_origin NOT FOUND, tx_index = " + tx_index)
             console.log("###?? Outside keywordStr analysis loop, call_linenum= "+call_linenum+"!x2=" + x + "reentrancy_found =" + reentrancy_found)
             if(reentrancy_found){
                call_index = find_the_callindex_of_flinenum(call_linenum, f_linenum, funcCtr) 
                console.log("call_index = " +call_index)
             }
             else
                 console.log("###?? reentrancy NOT FOUND, call_index = " + call_index)
             if(!reentrancy_found){
                if(sendFound) {
                   console.log("^^^ sendStr="+sendStr)
                   send_linenum= parseInt (find_send_line_number(sendStr))
                   console.log("send linenum =" + send_linenum)
                   send_index = parseInt (find_the_sendindex_of_flinenum(send_linenum, f_linenum, funcCtr))
                   console.log("send linenum =" + send_linenum)
                }
                else if (transferFound){
                   console.log("000 0 transfer linenum =" + transfer_linenum)
                   transfer_linenum= parseInt (find_transfer_line_number(transferStr))
                   console.log("000 00 transfer linenum =" + transfer_linenum)
                   transfer_index = parseInt (find_the_transferindex_of_flinenum(transfer_linenum, f_linenum, funcCtr))
                   console.log("000 000 transfer linenum =" + transfer_linenum)  

                }

             } 
             console.log("###?? Outside keywordStr analysis loop, call_linenum= "+call_linenum+"!x2=" + x + "reentrancy_found =" + reentrancy_found)
             console.log("send linenum =" + send_linenum+ "send_index =" + send_index) 
             console.log("transfer linenum =" + transfer_linenum+ "transfer_index =" + transfer_index) 
             //finding the function name and the arguments of function containing tx_origin and call and arguments
             if((!reentrancy_found) && (!tx_origin_found) && (!sendFound) && (!transferFound)){
                console.log("No vulnerability found stop")
                return
             }
             else if(tx_origin_found){
                if(reentrancy_found) {
                   if(tx_index != call_index){
                      console.log ("tx_origin and call can't be in different functions, not implemented")
                      return
                   }
                }
                else if(sendFound) {
                   if(tx_index != send_index){
                       console.log ("tx_origin and send can't be in different functions, not implemented")
                       return
                   }
                }
                else if(transferFound) {
                   if(tx_index != transfer_index){
                       console.log ("tx_origin and transfer can't be in different functions, not implemented")
                       return
                   }
                }
                console.log("In tx.origin block Finding the function name")
                console.log("In tx.origin block function ctr =" + funcCtr)    
                tx_call_func_linenum = funcCtr[tx_index]//tx_call_func_linenum means related to both tx.origin and call
                tx_call_func_name = funcStr[funcCtr]
                console.log("In tx.origin block tx_index and call_index are same")
                console.log("In tx.origin block func name is: " + funcStr[tx_index])
                transferFuncName = extract_the_function_name_system(funcStr[tx_index])
                console.log("In tx.origin block  After extract the function name system transferFuncName=" + transferFuncName );
                argStrWithComma = extract_the_function_argument_with_comma(funcStr[tx_index], transferFuncName)
                console.log("In tx.origin block? After extract the function argument "+"argStrWithComma= " + argStrWithComma);
             }//else if((tx_origin_found){
             //else {//if((!tx_origin_found){
                if(reentrancy_found) {//tx.origin not found thus we are finding function name based upon call line num and call_index
                   console.log("reentrancy found Finding the function name")
                   console.log("function ctr =" + funcCtr)    
                   call_func_linenum = funcCtr[call_index]//call_func_linenum means related to only call
                   call_func_name = funcStr[funcCtr]
                   console.log("1####tx_index not found thus tx_index and call_index are not same")
                   console.log("11###func name is: " + funcStr[call_index])
                   transferFuncName = extract_the_function_name_system(funcStr[call_index])
                   console.log("111### transferFuncName=" + transferFuncName );
                   argStrWithComma = extract_the_function_argument_with_comma(funcStr[call_index], transferFuncName)
                   console.log("1111### After extract the function argument "+"argStrWithComma= " + argStrWithComma); 
                }
                else if(sendFound) {//tx.origin not found thus we are finding function name based upon send line num and send_index
                   console.log("2sendFound Finding the function name")
                   console.log("22function ctr =" + funcCtr)    
                   send_func_linenum = funcCtr[send_index]//tx_call_func_linenum means related to both tx.origin and call
                   send_func_name = funcStr[funcCtr]
                   console.log("222####tx_index not found thus tx_index and send_index are not same")
                   console.log("222 2 ###func name is: " + funcStr[send_index])
                   transferFuncName = extract_the_function_name_system(funcStr[send_index])
                   console.log("222 22 ### transferFuncName=" + transferFuncName );
                   argStrWithComma = extract_the_function_argument_with_comma(funcStr[send_index], transferFuncName)
                   console.log("222 222 ### After extract the function argument "+"argStrWithComma= " + argStrWithComma); 
                }
                else if(transferFound){//tx.origin not found thus we are finding function name based upon send line num and send_index
                   console.log("transferFound Finding the function name transfer_index =" + transfer_index)
                   console.log("function ctr =" + funcCtr)    
                   transferSolid_func_linenum = funcCtr[transfer_index]//tx_call_func_linenum means related to both tx.origin and call
                   transferSolid_func_name = funcStr[funcCtr]
                   console.log("transfer_index ")
                   console.log("func name is: " + funcStr[transfer_index])
                   transferFuncName = extract_the_function_name_system(funcStr[transfer_index])
                   console.log("transferFuncName=" + transferFuncName );
                   argStrWithComma = extract_the_function_argument_with_comma(funcStr[transfer_index], transferFuncName)
                   console.log("After extract the function argument "+"argStrWithComma= " + argStrWithComma); 
                }
             //}//else {
                
             var commacount = (argStrWithComma.match(/,/g) || []).length;
                console.log("###?? commacount="+commacount);
                if(commacount != 0){//At both if and if-else we are calling the address payable function because compiler is not accepting address type with Ether transfer 
                   console.log("1Inside commacount NOT ZERO BLK ###?? commacount="+commacount+ "argStrWithComma=" + argStrWithComma);
                   if (argStrWithComma.search("address payable")>=0){
                      argStrN=separate_the_argument_name_and_type_with_address_payable(argStrWithComma)
                      console.log("1###?? argStrN = " + argStrN)
                      //argStrN = extract_the_function_argument_system(funcStr[tx_index], transferFuncName)
                      /*if(argLen){
                      console.log("Number of arguments is greater than 2. Not possible, skip this file");
                      continue;*/          
                      type1 = argStrN[0][0]
                      type2 = argStrN[1][0]
                      console.log("outsideFunc argStrN[0][0]"+argStrN[0][0])
                      console.log("outsideFunc argStrN[0][1]"+argStrN[0][1])
                      console.log("outsideFunc argStrN[1][0]"+argStrN[1][0])
                      console.log("outsideFunc argStrN[1][1]"+argStrN[1][1])
                   }
                   else{
                      //address payable with
                      console.log("Address Payable 2Inside commacount NOT ZERO BLK ###?? commacount="+commacount+ "argStrWithComma=" + argStrWithComma);
                      argStrN=separate_the_argument_name_and_type_with_address_payable(argStrWithComma) 
                      console.log("2###?? argStrN = " + argStrN)
                      //argStrN = extract_the_function_argument_system(funcStr[tx_index], transferFuncName)
                      /*if(argLen){
                      console.log("Number of arguments is greater than 2. Not possible, skip this file");
                      continue;*/          
                      type1 = argStrN[0][0]
                      type2 = argStrN[1][0]
                      console.log("outsideFunc argStrN[0][0]"+argStrN[0][0])
                      console.log("outsideFunc argStrN[0][1]"+argStrN[0][1])
                      console.log("outsideFunc argStrN[1][0]"+argStrN[1][0])
                      console.log("outsideFunc argStrN[1][1]"+argStrN[1][1])
                   }
                }//if(commacount != 0){
                else{//if commacount == 0, we have two cases: (1) length of argument string is zero i.e., transfer function has no argument (2) length of argument list is not zero i.e, we have only
                     //one argument without comma in the argument string
                     
                   if(argStrWithComma.length == 0) { //argStrWithComma != null hence we would use length, if commacount is zero then either argument's list's length is zero
                      no_argument = true;                                  //or arguent's list's length is not zero but the list has no comma i.e., arg list has one argument
                      //we will use this block to indicate that function has no argument and then perform the task i.e. execute the no argument function
                      console.log ("No arguments?????????")
                      //return
                   }
                   else {
                        console.log("3###?? argStrN = " + argStrN + "argStrWithComma= " + argStrWithComma + "Length= "+ argStrWithComma.length)
                        console.log("Why Entering Here ???????????? !!argStrWithComma=" + argStrWithComma)
                        if (argStrWithComma.search("address payable") >=0 ){
                           argStrN = separate_the_single_argument_name_and_type_with_address_payable(argStrWithComma)
                           type1 = argStrN[0][0]
                        }   
                        else if(argStrWithComma.search("address") >=0){
                           argStrN = separate_the_single_argument_name_and_type_without_address_payable(argStrWithComma)
                           type1 = argStrN[0][0]
                        }
                        else if(argStrWithComma.search("uint") >=0) {
                           argStrN = separate_the_single_argument_name_and_type_without_address_payable(argStrWithComma)
                           type1 = argStrN[0][0]
                        }
                   }  
                }//comma count ==0 
             //}//else
             //We have retrieved thefunction name and arguments, now execute the function
             console.log("Executing the assertion starts")
             //execute the function containing call and tx.origin  
             //function transferTo(address  to, uint amount) {....}
             categoryStr = find_Contract_Category(tx_origin_found, reentrancy_found, sendFound, transferFound, txStr)
             console.log("categoryStr = " + categoryStr)
             if ((send_linenum == -1) && (transfer_linenum == -1) && (call_linenum == -1)){
               console.log("!!!Stopping: No Ether transfer function found, No call, send, transfer found")
               return
             }
             const accounts = await web3.eth.getAccounts();
             const acc2 = accounts[2];
             acc2bal = await web3.eth.getBalance(acc2);
             web3.utils.fromWei(acc2bal, "ether");
             //console.log('!acc2 balance', acc2bal, 'address',acc2);
             const vic= artifacts.require("ERC20Token");//pass the SC name not the src file name      VICTIM NAME
             //console.log("Point1 ###1")
             const att= artifacts.require("ERC20TokenAtt");//pass the SC name not the src file name   ATTACKER NAME
             //console.log("Point2 ###2")
             const vicobj = await vic.new();
             //console.log("Point3 ###1")
             const attobj = await att.new();
             //console.log("Point4 ###1")
             amount = '11'
                     
             vicbal = await web3.eth.getBalance(vicobj.address)
             console.log("Point5 ###1")
             web3.utils.fromWei(vicbal, "ether")
             console.log(`Initial Victim:`,vicobj.address,` balance is ${vicbal}`)
             attbal = await web3.eth.getBalance(attobj.address)
             web3.utils.fromWei(attbal, "ether")
             console.log(`Initial Attacker:`,attobj.address,` balance is ${attbal}`)
             amount = '11'
             result1 = await web3.eth.sendTransaction({to:vicobj.address, from:acc2, value: web3.utils.toWei(amount)})
             console.log("receipt  : ", result1)
             console.log("sender   : ", result1.from)
             console.log("receiver : ", result1.to)
             vicbal = await web3.eth.getBalance(vicobj.address)
             web3.utils.fromWei(vicbal, "ether")
             console.log(`1Deposited ${amount} Ether from acc2:${acc2}, to victim:`, vicobj.address,` balance is ${vicbal}`)
             amount = '6'
             console.log("Testing0")
             vicPrevBal = vicbal   
              console.log("Testing00")       
             if(commacount===1){
                console.log("Testing& type1 = " + type1)
                type1 = type1.trim()
                console.log("Testing&& type2="+type2)
                type2 = type2.trim()
                console.log("@@@1 type1 = " + type1 + "len = " + type1.length+  "type2= " + type2)
                if((type1.trim() === "address") && (type2 === "uint")){
                    console.log("@@@2 type1 = " + type1 + "typ2= " + type2)
                    arg1 = attobj.address
                    arg2 = web3.utils.toWei(amount,"ether")
                    result2 = await vicobj[transferFuncName](arg1, arg2, {from:accounts[0]})//worked
                    //Note after changing the arguments here, we have to change the arguments of the victim SC, attacker Sc in the reentrant call, and the attacker SC's interface also
                }
                else if((type1 === "uint") && (type2 === "address")){
                    console.log("@@@3 type1 = " + type1 + "typ2= " + type2)
                    arg2 = attobj.address
                    arg1 = web3.utils.toWei(amount,"ether")
                    result2 = await vicobj[transferFuncName](arg1, arg2, {from:accounts[0]})//worked
                }
                else if((type1 === "address payable") && (type2 === "uint")){
                    console.log("@@@4 type1 = " + type1 + "typ2= " + type2 + "amount= " + amount +"tF=" + transferFuncName)
                    
                    arg1 = attobj.address
                    arg2 = web3.utils.toWei(amount,"ether")
                    result2 = await vicobj[transferFuncName](arg1, arg2, {from:accounts[0]})//worked
                    //Note after changing the arguments here, we have to change the arguments of the victim SC, attacker Sc in the reentrant call, and the attacker SC's interface also
                }
                else if((type1 === "uint") && (type2 === "address payable")){
                    console.log("@@@5 type1 = " + type1 + "typ2= " + type2)
                    arg2 =  attobj.address
                    arg1 = web3.utils.toWei(amount,"ether")
                    result2 = await vicobj[transferFuncName](arg1, arg2, {from:accounts[0]})//worked
                }
             }//(commacount===1){
             else if(commacount ==0){ //&& (argStrWithComma!= null)){
                console.log("Testing1")
                if(argStrWithComma.length == 0){
                   result2 = await vicobj[transferFuncName]({from:accounts[0]})//
                   console.log("@@@6 type1 = " + type1 + "typ2= " + type2)
                   console.log("###?? Comma Count = 0: ENtered here = " +  transferFuncName + "obj address=" + attobj.address)
                }
                else{
                   //if(type1 == "address payable")
                      arg1 = attobj.address, {from:accounts[0]}
                   //else
                      //arg1 = web3.utils.toWei('6',"ether")
                   //Note in this case the argument of transferTo is "address payable" but the argument of transfer is "address(this.baance)"
                   console.log("Testing2"+type1)
                   result2 = await vicobj[transferFuncName](arg1/*, {from:accounts[0]}*/)//worked
                   console.log("@@@7 type1 = " + type1 + "typ2= " + type2)
                }
             }
             console.log("receipt  : ", result2)
             console.log("sender   : ", result2.from)
             console.log("receiver : ", result2.to)
             console.log(`2Deposited ${amount} Ether to Attacker from victim:`, vicobj.address)
             vicbal = await web3.eth.getBalance(vicobj.address)
             web3.utils.fromWei(vicbal, "ether")
             attbal = await web3.eth.getBalance(attobj.address)
             web3
.utils.fromWei(attbal, "ether")
             console.log(`After deposit, Victim:`,vicobj.address,` balance is ${vicbal}`)
             console.log(`After deposit, Attacker:`,attobj.address,` balance is ${attbal}`)
             try{
                   assert.equal(vicbal,vicPrevBal ,"(1)Victim balance after transfer is Zero");
          
                 }catch(err){
                   console.log(err)
                  }
             try{
                   assert.equal(vicobj.address, attobj.address, "(2)Victim address is not same as the receiver or attacker address");
                }catch(err){
                   console.log(err)
                 }  
                   //This assertion is not true therefore victim is not the beneficary  of the transaction
             try{
                   assert.equal(attbal, '0', "(3)After transfer Attacker Balance is same as Victim's balance before transfer"); 
                }catch(err){
                   console.log(err)
                }
             ctr = 0
          }//for (let i = 0; i <1 files.length; i++) {
       }//try
       catch (error) {
          console.log(error)
       }
   callback();
   
   function find_Contract_Category(tx_origin_found, reentrancy_found, sendFound, transferFound, txStr){
      let categoryStr = ""
      if(reentrancy_found){
         categoryStr = categoryStr + "reentrant_"
         if(tx_origin_found){
            categoryStr = categoryStr + "tx.origin_"
            if(txStr.search("msg.sender") >= 0){
               categoryStr = categoryStr + "safe_"
            }
            else if (txStr.search("owner") >= 0){
               categoryStr = categoryStr + "unsafe_"
            }
         }
      }//if(reentrancy_found){   
      else{
         categoryStr = categoryStr + "non_reentrant_"
         if(tx_origin_found){
            categoryStr = categoryStr + "tx.origin_"
            if(!sendFound && !transferFound){
               categoryStr = categoryStr + "No-transfer"
               
               return categoryStr
            }
            if(txStr.search("msg.sender") >= 0){
               categoryStr = categoryStr + "safe_"
            }
            else if (txStr.search("owner") >= 0){
               categoryStr = categoryStr + "unsafe_"
            }
            if(sendFound)
                categoryStr = categoryStr + "send"
            else if(transferFound)
                categoryStr = categoryStr + "transfer"                
         }
         else {
            categoryStr = categoryStr + "Non-tx.origin"  
         }     
      }//else
      return categoryStr 
   }
   function separate_the_single_argument_name_and_type_with_address_payable(argStrWithComma){
      let argStrN=[[],[]]
      let argStrWithCommaBrok = []
      let temp = []
      var addrPayTypeAndVar = []
      let uintTypeAndVar = []
      let index =0
      let len =0
      let lenOfAP = 0
      let ptOfInsMarkChar = 0
      newStr = ""
      //let addrPayTypeAndVar = []
      console.log("IMP IMP Implement the code for dealing with arguments having address payable, argStrWithComma= "+ argStrWithComma)
      //console.log("value of str =" + argStrWithComma)
      //temp= argStrWithCommaBrok = argStrWithComma.split(',');
      //argStrWithCommaBrok[1] = argStrWithCommaBrok[1].trim()
      if(argStrWithComma. search ("address payable") >= 0){//this should be checked with all data type, it is going to unit
         index = argStrWithComma.indexOf("address payable")
         console.log("1index = " + index)
         len = "address payble".length 
         //console.log("len of address payable is" + len)
         ptOfInsMarkChar = len + index +1
         //console.log("ptOfInsMarkChar " + ptOfInsMarkChar)
         newStr = argStrWithComma.slice(0,ptOfInsMarkChar) + " # " + argStrWithComma.slice(ptOfInsMarkChar)
         //console.log("newStr =" + newStr)
         addrPayTypeAndVar = newStr.split("#")
         //console.log("addrPayTypeAndVar[0]=" + addrPayTypeAndVar[0] + "addrPayTypeAndVar[1]=" + addrPayTypeAndVar[1])
         argStrN[0][0] = addrPayTypeAndVar[0]
         argStrN[0][1] = addrPayTypeAndVar[1]
      }   
      else if (argStrWithComma. search ("address") >= 0){
         console.log("9Note only address is not implemented Error, checking the presence of 'payable' keyword") 
         if (argStrWithComma. search ("payable") >= 0){
            len = "payable".length  
            index = argStrWithComma.indexOf("payable")//Note index starts from 0
            console.log("10index of payable" + index)
            lenOfAp = index +  len
            console.log("11len of address payable is" + len)
            ptOfInsMarkChar = lenOfAp  
            console.log("12ptOfInsMarkChar " + ptOfInsMarkChar)
            newStr = argStrWithComma.slice(0,ptOfInsMarkChar) + " # " + argStrWithComma.slice(ptOfInsMarkChar)
            console.log("13newStr =" + newStr)
            addrPayTypeAndVar = newStr.split("#")
            console.log("14addrPayTypeAndVar=" + addrPayTypeAndVar[0] + "addrPayTypeAndVar[1]=" + addrPayTypeAndVar[1])
            argStrN[0][0] = addrPayTypeAndVar[0]
            argStrN[0][1] = addrPayTypeAndVar[1]
         }
         else
         {
          console.log("15Note only address is not implemented Error, returning")
          return
         }
      }
      else if(argStrWithComma. search ("uint") >= 0){
         //console.log("temp[0]" + temp[0])
         result = argStrWithComma.trim()
         uintTypeAndVar = result.split(" ")
         console.log("7###??  uintTypeAndVar[0] = "+ uintTypeAndVar[0] + "uintTypeAndVar[1]= "+uintTypeAndVar[1])
          argStrN[0][0] = uintTypeAndVar[0]
          argStrN[0][1] = uintTypeAndVar[1]
      }
      return argStrN
   }
   function separate_the_single_argument_name_and_type_without_address_payable(argStrWithComma){
      console.log("Implement the code for dealing with single argument without address payable")
   }
   function separate_the_argument_name_and_type_with_address_payable(argStrWithComma){
      //argStrWithComma = "address payable dest , uint amount"
      //let argStrWithComma = "address payable dest , uint amount"
      let argStrN=[[],[]]
      let argStrWithCommaBrok = []
      let temp = []
      var addrPayTypeAndVar = []
      let uintTypeAndVar = []
      let index =0
      let len =0
      let lenOfAP = 0
      let ptOfInsMarkChar = 0
      newStr = ""
      //let addrPayTypeAndVar = []
      console.log("??IMP IMP Implement the code for dealing with arguments having address payable, argStrWithComma= "+ argStrWithComma)
      //console.log("value of str =" + argStrWithComma)
      temp= argStrWithCommaBrok = argStrWithComma.split(',');
      argStrWithCommaBrok[1] = argStrWithCommaBrok[1].trim()
      console.log("&&& After Split and Trim, argStrWithCommaBrok[0]="+argStrWithCommaBrok[0]+ "argStrWithCommaBrok[1]" + argStrWithCommaBrok[1])
      if(argStrWithCommaBrok[0]. search ("address payable") >= 0){//this should be checked with all data type, it is going to unit
         index = argStrWithCommaBrok[0].indexOf("payable")
         console.log("1index = " + index)
         len = "payable".length 
         console.log("len of address payable is" + len)
         ptOfInsMarkChar = len + index +1
         console.log("ptOfInsMarkChar " + ptOfInsMarkChar)
         newStr = argStrWithCommaBrok[0].slice(0,ptOfInsMarkChar) + " # " + argStrWithCommaBrok[0].slice(ptOfInsMarkChar)
         console.log("newStr =" + newStr)
         addrPayTypeAndVar = newStr.split("#")
         console.log("addrPayTypeAndVar[0]=" + addrPayTypeAndVar[0] + "addrPayTypeAndVar[1]=" + addrPayTypeAndVar[1])
         argStrN[0][0] = addrPayTypeAndVar[0]
         argStrN[0][1] = addrPayTypeAndVar[1]
         console.log("&& argStrN[0][0]=" + argStrN[0][0] + "argStrN[0][1]=" + argStrN[0][1])
      }   
      else if (argStrWithCommaBrok[0]. search ("address") >= 0){
         console.log("9Note only address is not implemented Error, checking the presence of 'payable' keyword") 
         if (argStrWithCommaBrok[1]. search ("payable") >= 0){
            len = "payable".length  
            index = argStrWithCommaBrok[1].indexOf("payable")//Note index starts from 0
            console.log("10index of payable" + index)
            lenOfAp = index +  len
            console.log("11len of address payable is" + len)
            ptOfInsMarkChar = lenOfAp  
            console.log("12ptOfInsMarkChar " + ptOfInsMarkChar)
            newStr = argStrWithCommaBrok[1].slice(0,ptOfInsMarkChar) + " # " + argStrWithCommaBrok[1].slice(ptOfInsMarkChar)
            console.log("13newStr =" + newStr)
            addrPayTypeAndVar = newStr.split("#")
            console.log("14addrPayTypeAndVar[0]=" + addrPayTypeAndVar[0] + "addrPayTypeAndVar[1]=" + addrPayTypeAndVar[1])
            argStrN[1][0] = addrPayTypeAndVar[0]
            argStrN[1][1] = addrPayTypeAndVar[1]
         }
         else
         {
          console.log("15Note only address is not implemented Error, returning")
          return
         }
      }
      else if(argStrWithCommaBrok[0]. search ("uint") >= 0){
         console.log("temp[0]" + temp[0])
         result = temp[0].trim()
         uintTypeAndVar = result.split(" ")
         console.log("7###??  uintTypeAndVar[0] = "+ uintTypeAndVar[0] + "uintTypeAndVar[1]= "+uintTypeAndVar[1])
          argStrN[0][0] = uintTypeAndVar[0]
          argStrN[0][1] = uintTypeAndVar[1]
      }

      //this should be checked with all data type. Note we would repeat this for argStrWithCommaBrok[1]
      if(argStrWithCommaBrok[1]. search ("address payable") >= 0){
         index = argStrWithCommaBrok[1].indexOf("address payable")
         console.log("8index = " + index)
         len = "address payable".length 
         //console.log("len of address payable is" + len)
         ptOfInsMarkChar = len + index +1
         //console.log("ptOfInsMarkChar " + ptOfInsMarkChar)
         newStr = argStrWithCommaBrok[1].slice(0,ptOfInsMarkChar) + " # " + argStrWithCommaBrok[1].slice(ptOfInsMarkChar)
         //console.log("newStr =" + newStr)
         addrPayTypeAndVar = newStr.split("#")
         //console.log("addrPayTypeAndVar[0]=" + addrPayTypeAndVar[0] + "addrPayTypeAndVar[1]=" + addrPayTypeAndVar[1])
         argStrN[1][0] = addrPayTypeAndVar[0]
         argStrN[1][1] = addrPayTypeAndVar[1]
      }   
      else if (argStrWithCommaBrok[1]. search ("address") >= 0){//Note this also checks "address payable" but with multiple spaces
         console.log("9Note only address is not implemented Error, checking the presence of 'payable' keyword") 
         if (argStrWithCommaBrok[1]. search ("payable") >= 0){
            len = "payable".length  
            index = argStrWithCommaBrok[1].indexOf("payable")//Note index starts from 0
            console.log("10index of payable" + index)
            lenOfAp = index +  len
            console.log("11len of address payable is" + len)
            ptOfInsMarkChar = lenOfAp  
            console.log("12ptOfInsMarkChar " + ptOfInsMarkChar)
            newStr = argStrWithCommaBrok[1].slice(0,ptOfInsMarkChar) + " # " + argStrWithCommaBrok[1].slice(ptOfInsMarkChar)
            console.log("13newStr =" + newStr)
            addrPayTypeAndVar = newStr.split("#")
            console.log("14addrPayTypeAndVar[0]=" + addrPayTypeAndVar[0] + "addrPayTypeAndVar[1]=" + addrPayTypeAndVar[1])
            argStrN[1][0] = addrPayTypeAndVar[0]
            argStrN[1][1] = addrPayTypeAndVar[1]
         }
         else
         {
          console.log("15Note only address is not implemented Error, returning")
          return
         }
      }
      else if(argStrWithCommaBrok[1]. search ("uint") >= 0){
         console.log("temp[1]" + temp[1])
         result = temp[1].trim()
         uintTypeAndVar = result.split(" ")
         //console.log("3###??  uintTypeAndVar[0] ="+ uintTypeAndVar[0] + "uintTypeAndVar[1]="+uintTypeAndVar[1])
         argStrN[1][0] = uintTypeAndVar[0]
         argStrN[1][1] = uintTypeAndVar[1]
      }
      
     
      
      console.log("###??  argStrN[0][0] = "+ argStrN[0][0] + " argStrN[0][1]= "+argStrN[0][1])
      console.log("###??  argStrN[1][0] = "+ argStrN[1][0] + " argStrN[1][1]= "+argStrN[1][1])
      return argStrN
      
   }

   function extract_the_function_argument_with_comma(funcStr, transferFuncName){
      console.log("!!Inside extract the function argument Function Name String="+funcStr+"tfunName="+transferFuncName);  
      let words =   funcStr.split(transferFuncName); //step 1, split the function string using function name
      let argStr = null
      let strbwParen = null
      
      //console.log("words length=" + words.length)
      for(let i=0; i<2; ++i){//This will not be greater than 2 
         word = words[i]
         if(word.includes('(') && word.includes(')')){//Now find the string containing parenthesis, which would contain arguments
            //console.log("word ="+ word)
            strbwParen = word.substring( word.indexOf( '(' ) + 1, word.indexOf( ')' ) );
            //console.log ("strbwParenthesis="+strbwParen)
            //console.log("strbwp[0]="+strbwParen[0][0]+" strbwP[2]="+strbwParen[2][0])
            break
         }
         
      }
      return strbwParen
   }
   function separate_the_argument_name_and_type(strbwParen){
   /*function extract_the_function_argument_system(funcStr, transferFuncName){
      //https://stackoverflow.com/questions/8594097/javascript-split-string-into-2d-array
      console.log("Inside extract the function argument Function Name String="+funcStr+"tfunName="+transferFuncName);  
      let words =   funcStr.split(transferFuncName); //step 1, split the function string using function name
      let argStr = ""
      console.log("words length=" + words.length)
      for(let i=0; i<2; ++i){//This will not be greater than 2 
         word = words[i]
         if(word.includes('(') && word.includes(')')){//Now find the string containing parenthesis, which would contain arguments
            console.log("word ="+ word)
            strbwParen = word.substring( word.indexOf( '(' ) + 1, word.indexOf( ')' ) );
            console.log ("strbwParenthesis="+strbwParen)
            //console.log("strbwp[0]="+strbwParen[0][0]+" strbwP[2]="+strbwParen[2][0])
            break
         }
         
      }**/
      //https://stackoverflow.com/questions/44399184/javascript-how-to-get-string-between-brackets
      //const areThereAnyCommas = text.includes(',');
      
      strbwParen = strbwParen.split(",").map((x) => x.split(" ").filter((s) => s !== ''));
      console.log("!!strbwParen=",strbwParen)
      //var comma_count = (text.match(/,/g) || []).length; 
      //if (comma_count==0)
         
      return strbwParen






      /*argArray = strbwParen.split(",");
      let argArrayLen = argArray.length
      if (argArray.length === 0){
         console.log("Transfer function has no arguments")
         return 0
      }*/
      //for (let i = 0; i < argArray.length; i++) {
         //argArray[i] = argArray[i].split(" ");
      /*   argArray[i] = argArray[i].split(" ").filter(s => s !== '') 
      }
      for (let i = 0; i < argArray.length; i++) {*/
         //if (argArray[i] == null)
         //   continue;
         //else
         /*console.log("argArr["+i+"]="+argArray[i])
      } 
      console.log("argArr[0][0]"+argArray[0][0])
      console.log("argArr[0][1]"+argArray[0][1])
      console.log("argArr[1][0]"+argArray[1][0])
      console.log("argArr[1][1]"+argArray[1][1])*/
      /*console.log("arg="+argStr)
      argArr_TypeAndNameCombined = argStr.split(',');//Now finding the individual arguments
      if (argArr_TypeAndNameCombined.length > 2){
          console.log("Number of arguments is greater than 2, tool does not handle it")
          return false;
      }
         
      for(let i=0; i<argArr_TypeAndNameCombined.length; ++i){
         val[i] = argArr_TypeAndNameCombined.split(' ')
         console.log("argument"+argArr_TypeAndNameCombined[i])
        // let argArr_TypeAndNameSeparated[i] = argArr_TypeAndNameCombined[i].split(' ')
      }*/
      //return argArrayLen;
   }
   function extract_the_function_name_system(funcStr){
      let funcfoundCtr = 0
      let fNameCtr = 0
      let fName = []
      let retrieve_func_Name =false
      console.log("Inside extract the function name, Function Name String="+funcStr);   
      let words =   funcStr.split(' ');  
      for (let i = 0; i <words.length; i++) { 
         word= words[i]
         //console.log("word =" + word)
         if(word === "function"){//Note we can't use null for ''
            //console.log("Found the function keyword");
            funcfoundCtr++;
            if(funcfoundCtr==2){
               retrieve_func_Name = true;
               funcfoundCtr = 0
               continue
            }
         }
         if(retrieve_func_Name ===true){
               fName[fNameCtr] =  words[i]
               fNameCtr++;
            
         }
      }
      retfName = getName(fName[0]); 
      //retfName = retfName.join("")
      console.log("Inside extract the function name system !ret_fName = " + retfName.join(""))//removes comma in individual characters
      //for (let i=0; i<fName.length; i++)
      //   console.log("extract the function Name strings " + fName[i])
      return retfName.join("");
      
   }
   function getName(str){
      fName = []
      console.log("Inside getName str="+str)
      for(let i=0;i<str.length;i++){  
         if(str[i] == ' ' || str[i] =='(')
            break;
         fName[i] = str[i]
      }
      return fName;
   }

   function find_the_transferindex_of_flinenum(transfer_linenum, f_linenum, funcCtr) {
      let temp = []
      let index = -1
      let i=0
      let transferfunc_line_num = -1
      let found_index = false
      let transferfunc_line_num_found = false
      console.log("$Inside find_the_transferindex_of_flinenum, transfer_linenum="+transfer_linenum+"funcCtr="+funcCtr)
      console.log("$Inside find_the_transferindex_of_flinenum[0] ="+ f_linenum[0])
      console.log("$Inside find_the_transferindex_of_flinenum[1] ="+ f_linenum[1])
      console.log("$Inside find_the_transferindex_of_flinenum[2] ="+ f_linenum[2])
      console.log("$Inside find_the_transferindex_of send_linenum ="+ transfer_linenum)
      //sorting the f_linenum using built-in function, first store f_linenum in a temporary aray
      //const newArray = sourceArray.map(obj => ({...obj}));
      //https://stackoverflow.com/questions/16232915/how-to-copy-all-items-from-one-array-into-another
      //temp = f_linenum.map(obj => ({...obj})); ????NOT WORKING
      for( i =0; i<funcCtr; ++i)
         temp[i] = f_linenum[i]
      console.log("###???? temp =" + temp)
      //https://www.w3schools.com/js/js_array_sort.asp
      temp.sort(function(a, b){return b - a});//sorting in descending order
      console.log("###???? After sorting temp =" + temp)
      console.log("###?? Inside find_the_transferindex_of_flinenum, not sorted f_linenum = " + f_linenum)
      for( i =0; i<funcCtr; ++i){
         console.log("!Inside for find_the_transferindex_of_flinenum["+i+"]="+f_linenum[i]+" i ="+i +"transfer_linenum ="+transfer_linenum )
         
         //if(tx_linenum > f_linenum[i]){
         console.log("!Again transfer_linenum="+transfer_linenum+"temp["+i+"]="+temp[i])
         //x=call_linenum + 10
         //console.log("x="+x)
         //if(tx_linenum > f_linenum[i]){
         //x= tx_linenum
         //y = f_linenum[i]
         //tx_linenum = 10

         if(transfer_linenum > parseInt(temp[i])){//Note we have to make sure that both operands are strings
            console.log("transfer_linenum is greater")
            //found_index = true
            //index = i, Note we can't use 'i' because we have sorted the temp arr, so we will the value and then use the value to find index from f_linenum
            transferfunc_line_num =parseInt(temp[i])
            console.log("###?? func line num="+transferfunc_line_num)
            transferfunc_line_num_found = true
            break
         }
      }
      if(transferfunc_line_num_found) {
         //Now we would search the index using the value from f_linenum array
         console.log("###??transferfunc_line_num_found="+transferfunc_line_num_found + " " + transferfunc_line_num)
         for( i =0; i<funcCtr; ++i){
            if(parseInt(f_linenum[i]) == transferfunc_line_num){
               index = i
               found_index = true
            }
         }
      }
      else 
         console.log("transfer function line number not found PROBLEM")
      
      if(!found_index)
         console.log("### transfer INDEX NOT FOUND")
      else
         console.log("###?? transfer INDEX =" + index)
      return index
   }


   function find_the_sendindex_of_flinenum(send_linenum, f_linenum, funcCtr) {
      let temp = []
      let index = -1
      let i=0
      let sendfunc_line_num = -1
      let found_index = false
      let sendfunc_line_num_found = false
      console.log("$Inside find_the_sendindex_of_flinenum, send_linenum="+send_linenum+"funcCtr="+funcCtr)
      console.log("$Inside find_the_sendindex_of_flinenum[0] ="+ f_linenum[0])
      console.log("$Inside find_the_sendindex_of_flinenum[1] ="+ f_linenum[1])
      console.log("$Inside find_the_sendindex_of_flinenum[2] ="+ f_linenum[2])
      console.log("$Inside find_the_sendindex_of send_linenum ="+ send_linenum)
      //sorting the f_linenum using built-in function, first store f_linenum in a temporary aray
      //const newArray = sourceArray.map(obj => ({...obj}));
      //https://stackoverflow.com/questions/16232915/how-to-copy-all-items-from-one-array-into-another
      //temp = f_linenum.map(obj => ({...obj})); ????NOT WORKING
      for( i =0; i<funcCtr; ++i)
         temp[i] = f_linenum[i]
      console.log("###???? temp =" + temp)
      //https://www.w3schools.com/js/js_array_sort.asp
      temp.sort(function(a, b){return b - a});//sorting in descending order
      console.log("###???? After sorting temp =" + temp)
      console.log("###?? Inside find_the_sendindex_of_flinenum, not sorted f_linenum = " + f_linenum)
      for( i =0; i<funcCtr; ++i){
         console.log("!Inside for find_the_sendindex_of_flinenum["+i+"]="+f_linenum[i]+" i ="+i +"send_linenum ="+send_linenum )
         
         //if(tx_linenum > f_linenum[i]){
         console.log("!Again send_linenum="+send_linenum+"temp["+i+"]="+temp[i])
         //x=call_linenum + 10
         //console.log("x="+x)
         //if(tx_linenum > f_linenum[i]){
         //x= tx_linenum
         //y = f_linenum[i]
         //tx_linenum = 10

         if(send_linenum > parseInt(temp[i])){//Note we have to make sure that both operands are strings
            console.log("send_linenum is greater")
            //found_index = true
            //index = i, Note we can't use 'i' because we have sorted the temp arr, so we will the value and then use the value to find index from f_linenum
            sendfunc_line_num =parseInt(temp[i])
            console.log("###?? func line num="+sendfunc_line_num)
            sendfunc_line_num_found = true
            break
         }
      }
      if(sendfunc_line_num_found) {
         //Now we would search the index using the value from f_linenum array
         console.log("###??sendfunc_line_num_found="+sendfunc_line_num_found + " " + sendfunc_line_num)
         for( i =0; i<funcCtr; ++i){
            if(parseInt(f_linenum[i]) == sendfunc_line_num){
               index = i
               found_index = true
            }
         }
      }
      else 
         console.log("send function line number not found PROBLEM")
      
      if(!found_index)
         console.log("### send INDEX NOT FOUND")
      else
         console.log("###?? send INDEX =" + index)
      return index
   }

   
   function find_the_callindex_of_flinenum(call_linenum, f_linenum, funcCtr) {
      let temp = []
      let index = -1
      let i=0
      let callfunc_line_num = -1
      let found_index = false
      let callfunc_line_num_found = false
      console.log("$Inside find_the_callindex_of_flinenum, call_linenum="+call_linenum+"funcCtr="+funcCtr)
      console.log("$Inside find_the_callindex_of_flinenum[0] ="+ f_linenum[0])
      console.log("$Inside find_the_callindex_of_flinenum[1] ="+ f_linenum[1])
      console.log("$Inside find_the_callindex_of_flinenum[2] ="+ f_linenum[2])
      console.log("$Inside find_the_callindex_of call_linenum ="+ call_linenum)
      //sorting the f_linenum using built-in function, first store f_linenum in a temporary aray
      //const newArray = sourceArray.map(obj => ({...obj}));
      //https://stackoverflow.com/questions/16232915/how-to-copy-all-items-from-one-array-into-another
      //temp = f_linenum.map(obj => ({...obj})); ????NOT WORKING
      for( i =0; i<funcCtr; ++i)
         temp[i] = f_linenum[i]
      console.log("###???? temp =" + temp)
      //https://www.w3schools.com/js/js_array_sort.asp
      temp.sort(function(a, b){return b - a});//sorting in descending order
      console.log("###???? After sorting temp =" + temp)
      console.log("###?? Inside find_the_callindex_of_flinenum, not sorted f_linenum = " + f_linenum)
      for( i =0; i<funcCtr; ++i){
         console.log("!Inside for find_the_callindex_of_flinenum["+i+"]="+f_linenum[i]+" i ="+i +"call_linenum ="+call_linenum )
         
         //if(tx_linenum > f_linenum[i]){
         console.log("!Again call_linenum="+call_linenum+"temp["+i+"]="+temp[i])
         //x=call_linenum + 10
         //console.log("x="+x)
         //if(tx_linenum > f_linenum[i]){
         //x= tx_linenum
         //y = f_linenum[i]
         //tx_linenum = 10

         if(call_linenum > parseInt(temp[i])){//Note we have to make sure that both operands are strings
            console.log("call_linenum is greater")
            //found_index = true
            //index = i, Note we can't use 'i' because we have sorted the temp arr, so we will the value and then use the value to find index from f_linenum
            callfunc_line_num =parseInt(temp[i])
            console.log("###?? func line num="+callfunc_line_num)
            callfunc_line_num_found = true
            break
         }
      }
      if(callfunc_line_num_found) {
         //Now we would search the index using the value from f_linenum array
         console.log("###??callfunc_line_num_found="+callfunc_line_num_found + " " + callfunc_line_num)
         for( i =0; i<funcCtr; ++i){
            if(parseInt(f_linenum[i]) == callfunc_line_num){
               index = i
               found_index = true
            }
         }
      }
      else 
         console.log("call function line number not found PROBLEM")
      
      if(!found_index)
         console.log("### call INDEX NOT FOUND")
      else
         console.log("###?? call INDEX =" + index)
      return index
   }

   function find_the_txindex_of_flinenum(tx_linenum, f_linenum, funcCtr) {
      let temp = []
      let index = -1
      let i=0
      let txfunc_line_num = -1
      let found_index = false
      let txfunc_line_num_found = false
      console.log("$Inside find_the_txindex_of_flinenum, tx_linenum="+tx_linenum+"funcCtr="+funcCtr)
      console.log("$Inside find_the_txindex_of_flinenum[0] ="+ f_linenum[0])
      console.log("$Inside find_the_txindex_of_flinenum[1] ="+ f_linenum[1])
      console.log("$Inside find_the_txindex_of_flinenum[2] ="+ f_linenum[2])
      console.log("$Inside find_the_txindex_of tx_linenum ="+ tx_linenum)
      //sorting the f_linenum using built-in function, first store f_linenum in a temporary aray
      //const newArray = sourceArray.map(obj => ({...obj}));
      //https://stackoverflow.com/questions/16232915/how-to-copy-all-items-from-one-array-into-another
      //temp = f_linenum.map(obj => ({...obj})); ????NOT WORKING
      for( i =0; i<funcCtr; ++i)
         temp[i] = f_linenum[i]
      console.log("###???? temp =" + temp)
      //https://www.w3schools.com/js/js_array_sort.asp
      temp.sort(function(a, b){return b - a});//sorting in descending order
      console.log("###???? After sorting temp =" + temp)
      console.log("###?? Inside find_the_txindex_of_flinenum, not sorted f_linenum = " + f_linenum)
      for( i =0; i<funcCtr; ++i){
         console.log("!Inside for find_the_txindex_of_flinenum["+i+"]="+f_linenum[i]+" i ="+i +"tx_linenum ="+tx_linenum )
         
         //if(tx_linenum > f_linenum[i]){
         console.log("!Again tx_linenum="+tx_linenum+"temp["+i+"]="+temp[i])
         //x=call_linenum + 10
         //console.log("x="+x)
         //if(tx_linenum > f_linenum[i]){
         //x= tx_linenum
         //y = f_linenum[i]
         //tx_linenum = 10

         if(tx_linenum > parseInt(temp[i])){//Note we have to make sure that both operands are strings
            console.log("tx_linenum is greater")
            //found_index = true
            //index = i, Note we can't use 'i' because we have sorted the temp arr, so we will the value and then use the value to find index from f_linenum
            txfunc_line_num =parseInt(temp[i])
            console.log("###?? func line num="+txfunc_line_num)
            txfunc_line_num_found = true
            break
         }
      }
      if(txfunc_line_num_found) {
         //Now we would search the index using the value from f_linenum array
         console.log("###?? txfunc_line_num_found="+txfunc_line_num_found + " " + txfunc_line_num)
         for( i =0; i<funcCtr; ++i){
            if(parseInt(f_linenum[i]) == txfunc_line_num){
               index = i
               found_index = true
            }
         }
      }
      else 
         console.log("tx function line number not found PROBLEM")
      
      if(!found_index)
         console.log("### tx INDEX NOT FOUND")
      else
         console.log("###?? tx INDEX =" + index)
      return index
   }


   /*function find_the_index_of_flinenum(tx_linenum, f_linenum, funcCtr) {
      let index = -1
      let i=0
      console.log("$Inside find_the_index_of_flinenum, tx_linenum="+tx_linenum+"funcCtr="+funcCtr)
      console.log("$Inside find_the_index_of_flinenum[0] ="+ f_linenum[0])
      console.log("$Inside find_the_index_of_flinenum[1] ="+ f_linenum[1])
      console.log("$Inside find_the_index_of_flinenum[2] ="+ f_linenum[2])
      console.log("$Inside find_the_index_of tx_linenum ="+ tx_linenum)
      for( i =0; i<funcCtr; ++i){
         console.log("!Inside for find_the_index_of_flinenum["+i+"]="+f_linenum[i]+" i ="+i +"tx_linenum ="+tx_linenum )
         
         //if(tx_linenum > f_linenum[i]){
         console.log("!Again tx_linenum="+tx_linenum+"f_linenum["+i+"]="+f_linenum[i])
         x=tx_linenum + 10
         console.log("x="+x)
         //if(tx_linenum > f_linenum[i]){
         //x= tx_linenum
         //y = f_linenum[i]
         //tx_linenum = 10
         if(tx_linenum > parseInt(f_linenum[i])){//Note we have to make sure that both operands are strings
            console.log("tx is greater")
            index = i
            //index =parseInt(f_linenum[i])
            console.log("func line num="+f_linenum[i])
         }
      }
      console.log("### index ="+index)
      return index
   }*/

   function find_function_line_number(keywordStr){
      //! inside j==2 2 call statement= 11 =  call. =        (bool success,) = to.call.value(amount)("");
      //11 =  call. =        (bool success,) = to.call.value(amount)("");
      //https://stackoverflow.com/questions/1623221/how-to-find-a-number-in-a-string-using-javascript
      var r = /\d+/;
      //The expression \d+ means "one or more digits". Regular expressions by default are greedy meaning they'll grab as much as they can. Also, this:
      var s = keywordStr;
     
      console.log("function string ="+ keywordStr)


      let words =   keywordStr.split(' '); //number of lines in file
      for (let i = 0; i <words.length; i++) { 
         word= words[i]
         console.log("word =" + word)
         //NaN = not a number
         if(!isNaN(word) && word!=''){//Note we can't use null for ''
            console.log("numeric string = " + word)
            return word
         }
      }
   }
   function find_call_line_number(keywordStr){
       //! inside j==2 2 call statement= 11 =  call. =        (bool success,) = to.call.value(amount)("");
       //11 =  call. =        (bool success,) = to.call.value(amount)("");
      //https://stackoverflow.com/questions/1623221/how-to-find-a-number-in-a-string-using-javascript
      var r = /\d+/;
      //The expression \d+ means "one or more digits". Regular expressions by default are greedy meaning they'll grab as much as they can. Also, this:
      var s = keywordStr;
     
      console.log("***call string ="+ keywordStr)


      let words =   keywordStr.split(' '); //number of lines in file
      for (let i = 0; i <words.length; i++) { 
         word= words[i]
         console.log("word =" + word)
         //NaN = not a number
         if(!isNaN(word) && word!=''){//Note we can't use null for ''
            console.log("***numeric string = " + word)
            return word
         }
      }
             
   }
   function find_txorigin_line_number(keywordStr){
       //! inside j==2 2 call statement= 11 =  call. =        (bool success,) = to.call.value(amount)("");
       //11 =  call. =        (bool success,) = to.call.value(amount)("");
      //https://stackoverflow.com/questions/1623221/how-to-find-a-number-in-a-string-using-javascript
      var r = /\d+/;
      //The expression \d+ means "one or more digits". Regular expressions by default are greedy meaning they'll grab as much as they can. Also, this:
      var s = keywordStr;
     
      console.log("txorigin string ="+ keywordStr)


      let words =   keywordStr.split(' '); //number of lines in file
      for (let i = 0; i <words.length; i++) { 
         word= words[i]
         console.log("word =" + word)
         //NaN = not a number
         if(!isNaN(word) && word!=''){//Note we can't use null for ''
            console.log("numeric string = " + word)
            return word
         }
      }
             
   }

   function find_transfer_line_number(keywordStr){
       //! inside j==2 2 call statement= 11 =  call. =        (bool success,) = to.call.value(amount)("");
       //11 =  call. =        (bool success,) = to.call.value(amount)("");
      //https://stackoverflow.com/questions/1623221/how-to-find-a-number-in-a-string-using-javascript
      var r = /\d+/;
      //The expression \d+ means "one or more digits". Regular expressions by default are greedy meaning they'll grab as much as they can. Also, this:
      var s = keywordStr;
     
      console.log("000 000 transfer string ="+ keywordStr)


      let words =   keywordStr.split(' '); //number of lines in file
      for (let i = 0; i <words.length; i++) { 
         word= words[i]
         console.log("word =" + word)
         //NaN = not a number
         if(!isNaN(word) && word!=''){//Note we can't use null for ''
            console.log("numeric string = " + word)
            return word
         }
      }
             
   }
   function find_send_line_number(keywordStr){
       //! inside j==2 2 call statement= 11 =  call. =        (bool success,) = to.call.value(amount)("");
       //11 =  call. =        (bool success,) = to.call.value(amount)("");
      //https://stackoverflow.com/questions/1623221/how-to-find-a-number-in-a-string-using-javascript
      var r = /\d+/;
      //The expression \d+ means "one or more digits". Regular expressions by default are greedy meaning they'll grab as much as they can. Also, this:
      var s = keywordStr;
     
      console.log("send string ="+ keywordStr)


      let words =   keywordStr.split(' '); //number of lines in file
      for (let i = 0; i <words.length; i++) { 
         word= words[i]
         console.log("word =" + word)
         //NaN = not a number
         if(!isNaN(word) && word!=''){//Note we can't use null for ''
            console.log("numeric string = " + word)
            return word
         }
      }
             
   }



   function findContractName(contractStr){
        var ctr =0;
        const lineStr = [];
        let len = 0;
        let ch ='';
        let l = 0;
        let k=0;
        //lineStr[0] = "A1.sol";
        //lineStr[1] = "pragma solidity ^0.5.9";
        //lineStr[2] = "contract =  contract contractName {";       
        //len = lineStr[2].length;
        let valid_char_starts = false;
        let is_equal_to_found = false;
        let contract_Name_found = false;
        let firstcontract_Word_found = false;
        let secondcontract_Word_found = false;
        let secondcontract_Word_started = false;
        let secondcontract_Word_finished = false;
        let space_after_is_equal_found = false;
        let space_after_2nd_contract_Word_found = false;
        let space_after_contract_Name_found = false;
        let contract_Name_finished = false;
        let contract_Name_started = false;
        let strcontractName = [ ];
        let str1stContractWord = [ ]; 
        let str2ndContractWord = [ ];
        let result ="";
        const str2 = contractStr;//lineStr[2].slice();//copy
        len = str2.length;//lineStr[2].length;
        console.log("Inside findContractName() str2=" + str2 +"len =" + len);//ContractName string contains the line# also
        for (j=0; j<len; j++){
           //if (book_Name_finished)
                 //break;
           ch = str2.charAt(j);
           //console.log("!!ch = " + ch);
           if(ch=='{')
              console.log("curly bracket found");
              //Note we would focus on 3 characters, '='. space, '{' and Characters a- 
              //z and 0-9 
              //"contract =  contract contractName {"
           if(ch=='=' && !is_equal_to_found){//string should have only one '='
              is_equal_to_found = true;
              //console.log("debug: '=' found");
              continue;
           }
           else if(ch == ' ') {
              if(!is_equal_to_found){
                 continue;
              }
              else if(is_equal_to_found && !secondcontract_Word_started){
                 //console.log("Message 1: Space found after = and not 2nd contract word started");
                 continue;
              }
              else if (secondcontract_Word_started && !secondcontract_Word_finished){
                 secondcontract_Word_finished = true;
                 //console.log("space after second contract word finished found");
                 continue;
              }
              else if(secondcontract_Word_finished && !contract_Name_started){
                 //console.log("More space after second book word finished found");
                 continue;
              }
              else if(contract_Name_started){
                 contract_Name_finished = true;
                 space_after_contract_Name_found = true;
                 //console.log("!space after contract Name finished found");
                 continue;
              }
              //else if (secondcontract_Word_found && !contract_Name_started)
              //   continue;
              else if(contract_Name_finished){
                   //console.log("More space after contract Name finished");
                   continue;
              }
           }  
           else if(ch == '{') {
              //console.log("!Curly bracket found");
              if(contract_Name_started && !contract_Name_finished){
                    //console.log("contract Name finished");
                    contract_Name_finished= true;
              }
              break;
           }
           else if(ch!=' ' && ch!= '{' && ch!= '=') {
              if(!is_equal_to_found)
                 continue;//This corresponds to 1st contract word
              else if (is_equal_to_found && !secondcontract_Word_finished) {
                 if(!secondcontract_Word_started){
                    //console.log("second contract Word started");
                    secondcontract_Word_started = true;
                 }
                 str2ndContractWord[k]=ch;
                 k++;
                 //console.log("1curly bracket after contract Name found");
              }
              else if (secondcontract_Word_finished && !contract_Name_finished) {
                 if(!contract_Name_started){ 
                    //console.log("contract Name started");
                    contract_Name_started = true;
                 }
                 strcontractName[l]=ch;
                 l++;
                 //console.log("2curly bracket after book Name found" + strcontractName);
              }
           }  
        }//for(j=0;...)
        if (contract_Name_finished){
           //console.log("!strbookName=" + strcontractName);
           result = strcontractName.join("");
           console.log("result = " + result);
            //break;
        }
        return result;
   }//function ends   
   
  }


